{
  "hash": "737787045c461d8e5fd01762d1626e42",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Apprendre tidiverse : Maîtriser les dates en R avec lubridate\"\ndate: \"2025-02-25\"\ncategories: [R, Data Science, Dates, lubridate]\nimage: \"calendar.jpg\"\ntoc: true\nformat: \n  html:\n    code-fold: show\n    code-tools: true\n---\n\n\n\n\n\n\n## Pourquoi maîtriser les dates en R ?\n\nLes analyses de données commerciales, financières ou marketing impliquent presque toujours une dimension temporelle. Savoir manipuler efficacement les dates est donc une compétence indispensable pour tout analyste de données utilisant R. Dans ce tutoriel, nous allons :\n\n1. Explorer les fonctionnalités essentielles du package `lubridate`\n2. Appliquer ces connaissances à un projet complet d'analyse de données de vente\n\n## 1. Les bases de lubridate\n\n### Installation et chargement\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Installation (à faire une seule fois)\ninstall.packages(\"lubridate\")\n\n# Chargement\nlibrary(lubridate)\n```\n:::\n\n\n\n\n### Création de dates : l'approche intuitive\n\nLa force de `lubridate` réside dans sa syntaxe intuitive. Pour créer une date, il suffit d'utiliser une fonction dont le nom correspond à l'ordre des éléments.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Format année-mois-jour\nymd(\"2025-02-25\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Format jour-mois-année\ndmy(\"25-02-2025\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Format mois-jour-année (format américain)\nmdy(\"02/25/2025\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Fonctionne avec différents séparateurs ou sans\nymd(\"2025.02.25\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25\"\n```\n\n\n:::\n\n```{.r .cell-code}\nymd(\"20250225\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-tip}\nLes fonctions de création de date acceptent de nombreux formats et séparateurs, ce qui facilite le nettoyage des données importées de diverses sources.\n:::\n\n### Intégration de l'heure\n\nPour inclure l'heure, ajoutez simplement le suffixe correspondant :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Année-mois-jour heure-minute-seconde\nymd_hms(\"2025-02-25 14:30:45\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25 14:30:45 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Jour-mois-année heure-minute\ndmy_hm(\"25-02-2025 14:30\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25 14:30:00 UTC\"\n```\n\n\n:::\n:::\n\n\n\n\n## 2. Extraire et modifier les composants d'une date\n\n### Extraction d'informations\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Création d'une date\nma_date <- ymd(\"2025-02-25\")\n\n# Extraction des composants\nyear(ma_date)    # Année\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2025\n```\n\n\n:::\n\n```{.r .cell-code}\nmonth(ma_date)   # Mois (numérique)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nmonth(ma_date, label = TRUE, abbr = FALSE)  # Nom du mois complet\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] février\n12 Levels: janvier < février < mars < avril < mai < juin < juillet < ... < décembre\n```\n\n\n:::\n\n```{.r .cell-code}\nday(ma_date)     # Jour du mois\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n\n```{.r .cell-code}\nwday(ma_date, label = TRUE, week_start = 1)  # Jour de la semaine (débutant lundi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] mar\\\\.\nLevels: lun\\\\. < mar\\\\. < mer\\\\. < jeu\\\\. < ven\\\\. < sam\\\\. < dim\\\\.\n```\n\n\n:::\n\n```{.r .cell-code}\nquarter(ma_date) # Trimestre\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n### Modification des composants\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Copier la date pour démonstration\ndate_modifiee <- ma_date\n\n# Modification de l'année\nyear(date_modifiee) <- 2026\ndate_modifiee\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2026-02-25\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Modification du mois (en une ligne)\ndate_modifiee <- date_modifiee %>% month(5)\ndate_modifiee\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] févr\n12 Levels: janv < févr < mars < avr < mai < juin < juil < août < ... < déc\n```\n\n\n:::\n:::\n\n\n\n\n## 3. Arithmétique des dates\n\nL'un des grands avantages de `lubridate` est la simplicité des opérations arithmétiques :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nma_date <- ymd(\"2025-02-25\")\n\n# Ajouter différentes unités de temps\nma_date + days(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-03-07\"\n```\n\n\n:::\n\n```{.r .cell-code}\nma_date + weeks(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-03-11\"\n```\n\n\n:::\n\n```{.r .cell-code}\nma_date + months(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-05-25\"\n```\n\n\n:::\n\n```{.r .cell-code}\nma_date + years(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2026-02-25\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Combinaison d'opérations\nma_date + days(5) + months(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-04-02\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Différence entre deux dates\ndate1 <- ymd(\"2025-01-15\")\ndate2 <- ymd(\"2025-03-25\")\ninterval <- interval(date1, date2)\nas.period(interval)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2m 10d 0H 0M 0S\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-important}\nAttention à la différence entre `period` et `duration` ! \n- `months(1)` (période) : ajoute un mois calendaire (variable selon le mois)\n- `dmonths(1)` (durée) : ajoute exactement 30.44 jours\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Démonstration de la différence\nymd(\"2025-01-31\") + months(1)  # Respecte le calendrier\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nymd(\"2025-01-31\") + dmonths(1)  # Ajoute une durée fixe\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-03-02 10:30:00 UTC\"\n```\n\n\n:::\n:::\n\n\n\n\n## 4. Projet pratique : Analyse des ventes d'une chaîne de magasins\n\nMaintenant, appliquons ces connaissances à un projet concret. Nous allons analyser les données de vente d'une chaîne de magasins fictive pour identifier les tendances saisonnières et les opportunités commerciales.\n\n### 4.1 Génération des données de vente\n\nCommençons par créer un jeu de données réaliste :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fonction pour générer des ventes avec patterns saisonniers\ngenerer_ventes <- function(n_jours, date_debut) {\n  set.seed(123)\n  \n  # Séquence de dates\n  dates <- seq(ymd(date_debut), ymd(date_debut) + days(n_jours - 1), by = \"day\")\n  \n  # Tendance générale à la hausse\n  tendance <- seq(1, n_jours) * 5\n  \n  # Saisonnalité hebdomadaire (weekend +)\n  saisonnalite_hebdo <- ifelse(wday(dates) %in% c(1, 7), 2000, 0)\n  \n  # Saisonnalité mensuelle (fin de mois +)\n  saisonnalite_mensuelle <- ifelse(day(dates) >= 25, 1000, 0)\n  \n  # Saisonnalité annuelle (été et Noël +)\n  mois <- month(dates)\n  saisonnalite_annuelle <- case_when(\n    mois %in% c(7, 8) ~ 3000,  # Été\n    mois == 12 ~ 5000,         # Noël\n    mois == 1 ~ -1000,         # Janvier (après Noël)\n    TRUE ~ 0\n  )\n  \n  # Valeurs de base avec bruit aléatoire\n  base <- 10000\n  bruit <- rnorm(n_jours, mean = 0, sd = 1000)\n  \n  # Génération des ventes journalières\n  ventes <- base + tendance + saisonnalite_hebdo + saisonnalite_mensuelle + \n    saisonnalite_annuelle + bruit\n  \n  # Création du dataframe\n  data.frame(\n    date = dates,\n    ventes = round(pmax(ventes, 0)),\n    magasin = sample(c(\"Paris\", \"Lyon\", \"Marseille\", \"Bordeaux\", \"Lille\"), n_jours, replace = TRUE)\n  )\n}\n\n# Génération de deux ans de données\nventes <- generer_ventes(730, \"2023-01-01\")\n\n# Aperçu des données\nhead(ventes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        date ventes  magasin\n1 2023-01-01  10445    Paris\n2 2023-01-02   8780 Bordeaux\n3 2023-01-03  10574    Lille\n4 2023-01-04   9091     Lyon\n5 2023-01-05   9154    Paris\n6 2023-01-06  10745 Bordeaux\n```\n\n\n:::\n:::\n\n\n\n\n### 4.2 Exploration des données temporelles\n\nPréparons les données en ajoutant des dimensions temporelles utiles :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enrichissement des données avec composantes temporelles\nventes_enrichies <- ventes %>%\n  mutate(\n    annee = year(date),\n    mois = month(date, label = TRUE),\n    trimestre = quarter(date),\n    semaine = week(date),\n    jour_semaine = wday(date, label = TRUE, week_start = 1),\n    jour_mois = day(date),\n    weekend = ifelse(wday(date) %in% c(1, 7), \"Weekend\", \"Semaine\"),\n    saison = case_when(\n      month(date) %in% c(12, 1, 2) ~ \"Hiver\",\n      month(date) %in% c(3, 4, 5) ~ \"Printemps\",\n      month(date) %in% c(6, 7, 8) ~ \"Été\",\n      TRUE ~ \"Automne\"\n    )\n  )\n\n# Structure des données enrichies\nglimpse(ventes_enrichies)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 730\nColumns: 11\n$ date         <date> 2023-01-01, 2023-01-02, 2023-01-03, 2023-01-04, 2023-01-…\n$ ventes       <dbl> 10445, 8780, 10574, 9091, 9154, 10745, 11496, 9775, 8358,…\n$ magasin      <chr> \"Paris\", \"Bordeaux\", \"Lille\", \"Lyon\", \"Paris\", \"Bordeaux\"…\n$ annee        <dbl> 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2023, 202…\n$ mois         <ord> janv, janv, janv, janv, janv, janv, janv, janv, janv, jan…\n$ trimestre    <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ semaine      <dbl> 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, …\n$ jour_semaine <ord> dim\\., lun\\., mar\\., mer\\., jeu\\., ven\\., sam\\., dim\\., l…\n$ jour_mois    <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17…\n$ weekend      <chr> \"Weekend\", \"Semaine\", \"Semaine\", \"Semaine\", \"Semaine\", \"S…\n$ saison       <chr> \"Hiver\", \"Hiver\", \"Hiver\", \"Hiver\", \"Hiver\", \"Hiver\", \"Hi…\n```\n\n\n:::\n:::\n\n\n\n\n### 4.3 Analyse des tendances mensuelles\n\nAnalysons maintenant l'évolution mensuelle des ventes :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ventes mensuelles\nventes_mensuelles <- ventes_enrichies %>%\n  group_by(annee, mois) %>%\n  summarise(ventes_totales = sum(ventes)) %>%\n  ungroup()\n\n# Visualisation\nggplot(ventes_mensuelles, aes(x = mois, y = ventes_totales, fill = factor(annee))) +\n  geom_col(position = \"dodge\") +\n  scale_y_continuous(labels = label_number(suffix = \" €\", big.mark = \" \")) +\n  labs(\n    title = \"Ventes mensuelles par année\",\n    x = \"Mois\",\n    y = \"Ventes totales\",\n    fill = \"Année\"\n  ) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](tidyverse-guide_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\n### 4.4 Comparaison des jours de la semaine\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ventes par jour de semaine\nventes_jour_semaine <- ventes_enrichies %>%\n  group_by(jour_semaine, weekend) %>%\n  summarise(ventes_moyennes = mean(ventes)) %>%\n  ungroup()\n\n# Visualisation\nggplot(ventes_jour_semaine, aes(x = jour_semaine, y = ventes_moyennes, fill = weekend)) +\n  geom_col() +\n  scale_y_continuous(labels = label_number(suffix = \" €\", big.mark = \" \")) +\n  labs(\n    title = \"Ventes moyennes par jour de la semaine\",\n    x = \"Jour\",\n    y = \"Ventes moyennes\",\n    fill = \"Type de jour\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](tidyverse-guide_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\n### 4.5 Analyse des tendances saisonnières\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ventes par saison et par année\nventes_saison <- ventes_enrichies %>%\n  group_by(annee, saison) %>%\n  summarise(ventes_totales = sum(ventes)) %>%\n  ungroup()\n\n# Réordonner les saisons\nventes_saison$saison <- factor(ventes_saison$saison, \n                               levels = c(\"Printemps\", \"Été\", \"Automne\", \"Hiver\"))\n\n# Visualisation\nggplot(ventes_saison, aes(x = saison, y = ventes_totales, fill = factor(annee))) +\n  geom_col(position = \"dodge\") +\n  scale_y_continuous(labels = label_number(suffix = \" €\", big.mark = \" \")) +\n  labs(\n    title = \"Ventes totales par saison\",\n    x = \"Saison\",\n    y = \"Ventes totales\",\n    fill = \"Année\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](tidyverse-guide_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n\n### 4.6 Analyse des ventes par magasin dans le temps\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ventes mensuelles par magasin\nventes_magasin <- ventes_enrichies %>%\n  group_by(annee, mois, magasin) %>%\n  summarise(ventes_totales = sum(ventes)) %>%\n  ungroup()\n\n# Fusion année-mois pour la visualisation\nventes_magasin <- ventes_magasin %>%\n  mutate(periode = ymd(paste0(annee, \"-\", as.numeric(mois), \"-01\")))\n\n# Visualisation\nggplot(ventes_magasin, aes(x = periode, y = ventes_totales, color = magasin)) +\n  geom_line() +\n  geom_point() +\n  scale_x_date(date_labels = \"%b %Y\", date_breaks = \"2 months\") +\n  scale_y_continuous(labels = label_number(suffix = \" €\", big.mark = \" \")) +\n  labs(\n    title = \"Évolution des ventes par magasin\",\n    x = \"Période\",\n    y = \"Ventes totales\",\n    color = \"Magasin\"\n  ) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](tidyverse-guide_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\n### 4.7 Identification de jours spéciaux\n\nAnalysons les jours de vente exceptionnels :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcul des jours exceptionnels (ventes supérieures à la moyenne + 2 écarts-types)\nmoyenne_ventes <- mean(ventes_enrichies$ventes)\necart_type_ventes <- sd(ventes_enrichies$ventes)\nseuil_exceptionnel <- moyenne_ventes + 2 * ecart_type_ventes\n\njours_exceptionnels <- ventes_enrichies %>%\n  filter(ventes > seuil_exceptionnel) %>%\n  arrange(desc(ventes))\n\n# Affichage des 10 meilleurs jours de vente\nknitr::kable(\n  head(jours_exceptionnels %>% \n         select(date, jour_semaine, mois, ventes, magasin), 10),\n  caption = \"Top 10 des jours de vente exceptionnels\",\n  format.args = list(big.mark = \" \")\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Top 10 des jours de vente exceptionnels\n\n|date       |jour_semaine |mois | ventes|magasin   |\n|:----------|:------------|:----|------:|:---------|\n|2024-12-15 |dim\\.        |déc  | 22 016|Marseille |\n|2024-12-28 |sam\\.        |déc  | 21 829|Marseille |\n|2024-12-29 |dim\\.        |déc  | 20 912|Lyon      |\n|2023-12-30 |sam\\.        |déc  | 20 845|Bordeaux  |\n|2024-12-07 |sam\\.        |déc  | 20 824|Lille     |\n|2023-12-31 |dim\\.        |déc  | 20 643|Marseille |\n|2024-12-30 |lun\\.        |déc  | 20 636|Paris     |\n|2024-12-14 |sam\\.        |déc  | 20 483|Marseille |\n|2023-12-09 |sam\\.        |déc  | 20 386|Paris     |\n|2023-12-26 |mar\\.        |déc  | 20 371|Bordeaux  |\n\n\n:::\n:::\n\n\n\n\n### 4.8 Analyse des intervalles entre pics de vente\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Intervalles entre jours exceptionnels\njours_pic <- jours_exceptionnels %>%\n  arrange(date) %>%\n  pull(date)\n\n# Calcul des intervalles (en jours)\nintervalles <- diff(jours_pic)\n\n# Statistiques sur les intervalles\nresume_intervalles <- data.frame(\n  intervalle_min = min(intervalles),\n  intervalle_median = median(intervalles),\n  intervalle_moyen = mean(intervalles),\n  intervalle_max = max(intervalles)\n)\n\nknitr::kable(resume_intervalles, \n       caption = \"Statistiques sur les intervalles entre pics de vente (en jours)\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Statistiques sur les intervalles entre pics de vente (en jours)\n\n|intervalle_min |intervalle_median |intervalle_moyen |intervalle_max |\n|:--------------|:-----------------|:----------------|:--------------|\n|1 days         |1 days            |11.72727 days    |188 days       |\n\n\n:::\n:::\n\n\n\n\n### 4.9 Prévision simple basée sur les tendances historiques\n\nNous pouvons utiliser lubridate pour extrapoler les ventes futures en nous basant sur les patterns saisonniers identifiés :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Création de dates futures pour prévision\ndates_futures <- seq(max(ventes$date) + days(1), \n                     max(ventes$date) + days(30), by = \"day\")\n\n# Préparation du dataframe pour les prévisions\nprevisions <- data.frame(\n  date = dates_futures,\n  jour_semaine = wday(dates_futures, label = TRUE),\n  mois = month(dates_futures, label = TRUE),\n  jour_mois = day(dates_futures)\n)\n\n# Application des facteurs saisonniers identifiés\nprevisions <- previsions %>%\n  mutate(\n    facteur_weekend = ifelse(wday(date) %in% c(1, 7), 1.2, 1),\n    facteur_fin_mois = ifelse(jour_mois >= 25, 1.1, 1),\n    facteur_mois = case_when(\n      mois %in% c(\"juil.\", \"août\") ~ 1.3,\n      mois == \"déc.\" ~ 1.5,\n      mois == \"janv.\" ~ 0.9,\n      TRUE ~ 1\n    ),\n    ventes_prevues = 15000 * facteur_weekend * facteur_fin_mois * facteur_mois\n  )\n\n# Aperçu des prévisions\nknitr::kable(\n  head(previsions %>% \n         select(date, jour_semaine, ventes_prevues), 10),\n  caption = \"Prévision des ventes pour les 10 prochains jours\",\n  format.args = list(big.mark = \" \")\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Prévision des ventes pour les 10 prochains jours\n\n|date       |jour_semaine | ventes_prevues|\n|:----------|:------------|--------------:|\n|2024-12-31 |mar\\.        |         16 500|\n|2025-01-01 |mer\\.        |         15 000|\n|2025-01-02 |jeu\\.        |         15 000|\n|2025-01-03 |ven\\.        |         15 000|\n|2025-01-04 |sam\\.        |         18 000|\n|2025-01-05 |dim\\.        |         18 000|\n|2025-01-06 |lun\\.        |         15 000|\n|2025-01-07 |mar\\.        |         15 000|\n|2025-01-08 |mer\\.        |         15 000|\n|2025-01-09 |jeu\\.        |         15 000|\n\n\n:::\n:::\n\n\n\n\n## 5. Applications pratiques avancées avec lubridate\n\n### 5.1 Création de périodes glissantes (rolling periods)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcul des moyennes mobiles sur 7 jours\nventes_moyennes_mobiles <- ventes %>%\n  arrange(date) %>%\n  mutate(\n    ventes_moy_7j = zoo::rollmean(ventes, k = 7, fill = NA, align = \"right\"),\n    periode_debut = date - days(6),\n    periode_fin = date\n  )\n\n# Visualisation des dernières 30 observations\ntail_ventes <- tail(ventes_moyennes_mobiles, 30)\n\nggplot(tail_ventes, aes(x = date)) +\n  geom_line(aes(y = ventes), color = \"gray50\") +\n  geom_line(aes(y = ventes_moy_7j), color = \"blue\", size = 1) +\n  scale_y_continuous(labels = label_number(suffix = \" €\", big.mark = \" \")) +\n  labs(\n    title = \"Ventes quotidiennes vs. moyenne mobile sur 7 jours\",\n    subtitle = \"30 derniers jours d'observation\",\n    x = \"Date\",\n    y = \"Ventes\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](tidyverse-guide_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n\n### 5.2 Calcul d'intervalles entre événements\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identification des jours où les ventes dépassent 20 000 €\njours_20k <- ventes %>%\n  filter(ventes > 20000) %>%\n  arrange(date) %>%\n  pull(date)\n\n# Calcul des intervalles entre ces jours\nintervalles_20k <- data.frame(\n  date_debut = head(jours_20k, -1),\n  date_fin = tail(jours_20k, -1),\n  intervalle = as.numeric(diff(jours_20k))\n)\n\n# Affichage des 5 premiers intervalles\nknitr::kable(\n  head(intervalles_20k, 5),\n  caption = \"Intervalles (en jours) entre les ventes dépassant 20 000 €\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Intervalles (en jours) entre les ventes dépassant 20 000 €\n\n|date_debut |date_fin   | intervalle|\n|:----------|:----------|----------:|\n|2023-12-09 |2023-12-26 |         17|\n|2023-12-26 |2023-12-30 |          4|\n|2023-12-30 |2023-12-31 |          1|\n|2023-12-31 |2024-12-07 |        342|\n|2024-12-07 |2024-12-14 |          7|\n\n\n:::\n:::\n\n\n\n\n### 5.3 Analyse par saison commerciale\n\nDéfinissons des saisons commerciales personnalisées et analysons les performances :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Définition des périodes commerciales\nperiodes_commerciales <- function(date) {\n  case_when(\n    (month(date) == 11 & day(date) >= 25) | \n      (month(date) == 12 & day(date) <= 31) ~ \"Fêtes de fin d'année\",\n    (month(date) >= 6 & month(date) <= 8) ~ \"Période estivale\",\n    (month(date) >= 1 & month(date) <= 2) ~ \"Soldes d'hiver\",\n    (month(date) >= 6 & month(date) <= 7 & day(date) <= 15) ~ \"Soldes d'été\",\n    TRUE ~ \"Période normale\"\n  )\n}\n\n# Application à nos données\nventes_periodes <- ventes %>%\n  mutate(periode_commerciale = periodes_commerciales(date))\n\n# Analyse des ventes par période commerciale\nresume_periodes <- ventes_periodes %>%\n  group_by(periode_commerciale) %>%\n  summarise(\n    ventes_totales = sum(ventes),\n    ventes_moyennes = mean(ventes),\n    nb_jours = n()\n  ) %>%\n  arrange(desc(ventes_moyennes))\n\n# Visualisation\nknitr::kable(\n  resume_periodes,\n  caption = \"Performance des ventes par période commerciale\",\n  format.args = list(big.mark = \" \")\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Performance des ventes par période commerciale\n\n|periode_commerciale  | ventes_totales| ventes_moyennes| nb_jours|\n|:--------------------|--------------:|---------------:|--------:|\n|Fêtes de fin d'année |      1 295 373|       17 744.84|       73|\n|Période estivale     |      2 707 913|       14 716.92|      184|\n|Période normale      |      4 472 982|       12 635.54|      354|\n|Soldes d'hiver       |      1 341 800|       11 275.63|      119|\n\n\n:::\n:::\n\n\n\n\n## 6. Conseils pratiques pour travailler avec les dates\n\n### 6.1 Formatage des dates pour affichage\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemples de formatage\nma_date <- ymd(\"2025-02-25\")\n\nformats <- c(\n  \"%d/%m/%Y\", \n  \"%A %d %B %Y\", \n  \"%d %b %Y\", \n  \"Semaine %U, %Y\"\n)\n\n# Application des différents formats\nformats_affiches <- sapply(formats, function(fmt) format(ma_date, fmt))\n\n# Affichage des résultats\ndata.frame(\n  Format = formats,\n  Résultat = formats_affiches\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                       Format              Résultat\n%d/%m/%Y             %d/%m/%Y            25/02/2025\n%A %d %B %Y       %A %d %B %Y mardi 25 février 2025\n%d %b %Y             %d %b %Y         25 févr. 2025\nSemaine %U, %Y Semaine %U, %Y      Semaine 08, 2025\n```\n\n\n:::\n:::\n\n\n\n\n### 6.2 Gestion des fuseaux horaires\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Création d'une date avec heure et fuseau horaire\ndate_paris <- ymd_hms(\"2025-02-25 14:30:00\", tz = \"Europe/Paris\")\ndate_paris\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25 14:30:00 CET\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Conversion vers d'autres fuseaux horaires\ndate_ny <- with_tz(date_paris, tzone = \"America/New_York\")\ndate_tokyo <- with_tz(date_paris, tzone = \"Asia/Tokyo\")\n\n# Comparaison\ndata.frame(\n  Ville = c(\"Paris\", \"New York\", \"Tokyo\"),\n  Heure_locale = c(\n    format(date_paris, \"%H:%M:%S\"),\n    format(date_ny, \"%H:%M:%S\"),\n    format(date_tokyo, \"%H:%M:%S\")\n  ),\n  Date = c(\n    format(date_paris, \"%d %b %Y\"),\n    format(date_ny, \"%d %b %Y\"),\n    format(date_tokyo, \"%d %b %Y\")\n  ),\n  Fuseau = c(tz(date_paris), tz(date_ny), tz(date_tokyo))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Ville Heure_locale          Date           Fuseau\n1    Paris     14:30:00 25 févr. 2025     Europe/Paris\n2 New York     08:30:00 25 févr. 2025 America/New_York\n3    Tokyo     22:30:00 25 févr. 2025       Asia/Tokyo\n```\n\n\n:::\n:::\n\n\n\n\n### 6.3 Traitement des données manquantes dans les dates\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemple de dates avec valeurs manquantes\ndates_avec_na <- c(\"2025-02-25\", NA, \"2025-03-01\")\ndates_parsees <- ymd(dates_avec_na)\ndates_parsees\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25\" NA           \"2025-03-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Vérification des NA\nis.na(dates_parsees)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Filtrage des NA\ndates_parsees[!is.na(dates_parsees)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-02-25\" \"2025-03-01\"\n```\n\n\n:::\n:::\n\n\n\n\n## 7. Conclusion et bonnes pratiques\n\nLe package `lubridate` offre une approche intuitive et puissante pour manipuler les dates en R, ce qui est essentiel pour l'analyse de données commerciales. Voici quelques bonnes pratiques à retenir :\n\n1. **Cohérence des formats** : Standardisez vos dates dès l'importation des données\n2. **Enrichissez vos données** : Ajoutez des dimensions temporelles pertinentes (jour de semaine, mois, saison...)\n3. **Attention aux fuseaux horaires** : Soyez explicite dans leur gestion, surtout pour les données internationales\n4. **Pensez en périodes** : Utilisez les concepts de `period` et `duration` selon vos besoins\n5. **Évitez les calculs manuels** : Utilisez les fonctions spécialisées (`interval`, `time_length`, etc.)\n\n### Points clés à retenir\n\n- **Création de dates** : `ymd()`, `dmy()`, `mdy()`\n- **Extraction de composants** : `year()`, `month()`, `day()`, `wday()`\n- **Opérations arithmétiques** : `+ days()`, `+ months()`, `+ years()`\n- **Intervalles** : `interval()`, `as.period()`, `time_length()`\n- **Arrondis** : `round_date()`, `floor_date()`, `ceiling_date()`\n\nMaîtriser ces fonctions vous permettra d'analyser efficacement la dimension temporelle de vos données commerciales et d'en extraire des insights précieux pour votre entreprise.\n\n## Pour aller plus loin\n\n- La [documentation officielle de lubridate](https://lubridate.tidyverse.org/)\n- Le livre [R for Data Science](https://r4ds.hadley.nz/) de Hadley Wickham\n- Les packages complémentaires : `tsibble` pour les séries temporelles, `timetk` pour l'analyse temporelle avancée",
    "supporting": [
      "tidyverse-guide_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}